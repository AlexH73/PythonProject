"""
Спираль

Требуется вывести квадрат, состоящий из N×N клеток, заполненных числами от 1 до N2 по спирали (см. примеры).
Входные данные

Программа получает на вход одно число n.
Выходные данные

Программа должна вывести матрицу, заполненную числами от 1 до N2 по спирали,
при этом между числами может быть любое количество пробелов. Не допускается начинать спираль в ином,
кроме верхнего левого, углу, закручивать спираль против часовой стрелки или изнутри наружу.
"""
def print_spiral_matrix(n):
    """
    Создает и выводит на экран квадратную матрицу n x n, заполненную числами
    по спирали.

    Args:
        n (int): Размерность матрицы.
    """

    # 1. Инициализация матрицы
    #    Создаем квадратную матрицу n x n, заполненную нулями.
    matrix = [[0] * n for _ in range(n)]

    # 2. Заполнение матрицы по спирали
    #    Инициализируем переменные:
    #    - i: Текущее число для заполнения матрицы.
    #    - x, y: Текущие координаты в матрице.
    #    - d_row, d_columm: Направления движения (сначала вправо).
    i = 1
    x = 0
    y = -1
    d_row = 0  # Перемещение по строкам
    d_columm = 1 # Перемещение по столбцам

    #    Цикл while, пока не заполним все ячейки матрицы.
    while i <= n ** 2:
        #    Проверяем, можно ли двигаться в текущем направлении.
        if 0 <= x + d_row < n and 0 <= y + d_columm < n and matrix[x + d_row][y + d_columm] == 0:
            x += d_row # Меняем координаты
            y += d_columm # Меняем координаты
            matrix[x][y] = i # Заполняем ячейку
            i += 1 # Увеличиваем число
        #    Если движение в текущем направлении невозможно,
        #    меняем направление по часовой стрелке.
        else:
            if d_columm == 1:
                d_columm = 0
                d_row = 1
            elif d_row == 1:
                d_row = 0
                d_columm = -1
            elif d_columm == -1:
                d_columm = 0
                d_row = -1
            elif d_row == -1:
                d_row = 0
                d_columm = 1

    # 3. Вывод матрицы
    #    Находим длину максимального числа (для правильного выравнивания)
    length = len(str(n**2))
    #   Выводим на экран элементы матрицы, выравнивая их.
    for row in matrix:
        for elem in row:
            print(str(elem).rjust(length), end=" ")
        print()

# Пример использования функции
n = int(input("Введите число: "))
print_spiral_matrix(n)

"""
Рекомендации по оптимизации:

    Избежать повторений условий:
        Можно использовать список направлений движения для более компактной записи условий.
        Это улучшит читаемость и облегчит возможные изменения алгоритма.
    Упростить логику заполнения:
        Сейчас используется явное переключение направлений движения, что можно заменить одним списком и переходом по его индексам.
        Так будет проще добавить дополнительные возможности (например заполнение против часовой стрелки).
    Улучшить читаемость:
        Добавить именование переменных, которые используются для передвижения, чтобы код стал более понятным Оптимизированный код:

"""
"""
def print_spiral_matrix_optimized(n):
    
    #Создает и выводит на экран квадратную матрицу n x n, заполненную числами по спирали.
    #(Оптимизированная версия)

    #Args:
    #    n (int): Размерность матрицы.
    
    matrix = [[0] * n for _ in range(n)]

    num = 1 # Текущее значение
    row = 0 # текущая строка
    col = 0 # текущий столбец
    direction_index = 0 # текущее направление
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Направления движения (вправо, вниз, влево, вверх)

    while num <= n ** 2:
        matrix[row][col] = num # Записываем значение
        num += 1 # Увеличиваем значение

        next_row = row + directions[direction_index][0] # Вычисляем следующую строку
        next_col = col + directions[direction_index][1] # Вычисляем следующий столбец

        # Проверяем, можем ли двигаться дальше
        if 0 <= next_row < n and 0 <= next_col < n and matrix[next_row][next_col] == 0:
            row = next_row # Обновляем текущую строку
            col = next_col # Обновляем текущий столбец
        else:
             # Меняем направление движения
            direction_index = (direction_index + 1) % 4
            row += directions[direction_index][0] # Обновляем текущую строку
            col += directions[direction_index][1] # Обновляем текущий столбец
    
    length = len(str(n**2)) # Вычисляем длинну максимального значения
    for row_matrix in matrix: # Перебираем строки матрицы
        for elem in row_matrix: # Перебираем элементы матрицы
            print(str(elem).rjust(length), end=" ") # Выводим с выравниванием
        print()

# Пример использования функции
# n = int(input())
# print_spiral_matrix_optimized(n)
"""


"""
Изменения в оптимизированном коде:

    Используется список направлений directions: Упрощается логика переключения направлений, код стал короче и понятнее.
    Переключение направления через индекс: Теперь мы переключаем направление, меняя индекс direction_index, что делает код более гибким.
    Более понятные имена переменных: Использованы более понятные имена row, col, direction_index, что делает код более читаемым.

Теперь код не только выполняет ту же задачу, но также является более читаемым, гибким и оптимизированным. В зависимости от ваших требований, вы можете использовать как начальный, так и оптимизированный код.

"""